/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pkg493final;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Scanner;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.FileWriter;
import java.util.logging.Level;
import java.util.logging.Logger;
import static pkg493final.encryptDecrypt.*;


/**
 *
 * @author alana
 */
public class Main {
    //Initialize the session array and prime. While the program is running,
    // it will store the array of shares. This allows the user to check if shares
    // are correct to combine and retrieve the key.
    // a more practical implementation probably exists, but I wasn't sure how
    // else to compare if the shares are correct to retrieve the key?
    public secrets[] sessionArr;
    private BigInteger[] neededToCombine;
    private secrets[] totalKeys;
    private BigInteger sessionPrime;
    private int sessionCombine;
    
    // Set session's prime
    public void setPrime(BigInteger p) {
    sessionPrime = p;
    }
    
    // Set session's needed coefficients.
    public void setCombine(int i)
    {
        sessionCombine = i;
    }    
    
    public BigInteger[] setCombineArray(int i) {
        neededToCombine = new BigInteger[i];
        return neededToCombine;
    }
    
    public BigInteger[] getCombineArray() {
        return neededToCombine;
    }
    
     public secrets[] setTotal(int i) {
        totalKeys = new secrets[i];
        return totalKeys;
    }
    
    public secrets[] getTotal() {
        return totalKeys;
    }
    
    // The "secrets" class is an object used to store an index *and* an
    // index's BigInteger split share value.
    class secrets {
        int index;
        BigInteger secretShare;
        
        public secrets(int i, BigInteger S) {
            this.index = i;
            this.secretShare = S;
        }
    }
    
    // shares to byte array
    class byteSecrets {
        int index;
        byte secretShare;
        
        public byteSecrets(int i, byte b) {
            this.index = i;
            this.secretShare = b;
        }
    }
    
    /**
     * Check that cNext is less than prime, and greater than/not 0
     * @param cNext next coefficient
     * @param prime our prime
     * @param random SecureRandom to generate coefficients
     * @return validated cNext
     */
    public BigInteger check(BigInteger cNext, BigInteger prime, SecureRandom random) {
        boolean trueFalse = false;
        if (cNext.compareTo(BigInteger.ZERO) > 0 && cNext.compareTo(prime) < 0) {
            trueFalse = true;
        }
        
        while (trueFalse == false) //compare that they are different+less from prime and not 0
                {
                    cNext = new BigInteger(prime.bitLength(), random);
                    if (cNext.compareTo(BigInteger.ZERO) > 0 && cNext.compareTo(prime) < 0) {
                        trueFalse = true;
                    }        
                }
        return cNext;
    }
    
    /**
     * 
     * @param toCombine The minimum number of shares required to retrieve the key.
     * @param random Random number gen class (SecureRandom)
     * @param s Our session's secret that will be split into shares.
     * @param prime The prime generated by our secret's bitLength and SecureRandom
     * @return Returns an array of BigInteger coefficients back to splitShares
     */
    public BigInteger[] getCoefficients(int toCombine, SecureRandom random, BigInteger s, BigInteger prime) {
        BigInteger[] c = new BigInteger[toCombine];
        for (int i = 1; i < toCombine; i++) {
            BigInteger cNext = new BigInteger(prime.bitLength(), random); //first generate random coefficients
            cNext = check(cNext,prime,random);
            c[i] = cNext;
        }
        return c;
    }
   
    
    /**
     * 
     * @param helper i^j.mod(prime)
     * @param cHelper coefficient #j
     * @param prime our prime
     * @return c * i^j.mod(prime) . mod(prime)
     */
    public BigInteger createShare(BigInteger helper, BigInteger cHelper, BigInteger prime) {
        BigInteger split = (cHelper.multiply(helper));
        split = split.mod(prime);
        return split;
    }
    
    /**
     * 
     * @param share for each share from the array
     * @param i index i
     * @param c coefficient array
     * @param prime our prime
     * @return return generated share
     */
    public BigInteger forEach(BigInteger share, int i, BigInteger[] c, BigInteger prime) {
        for (int j = 1; j < c.length; j++) {
                //share += (coefficient #j i^j) % prime
                BigInteger helper = BigInteger.valueOf(i).pow(j);
                helper = helper.mod(prime);
                BigInteger  cHelper = c[j];
                BigInteger split = createShare(helper,cHelper,prime);
                share = share.add(split);
            }
        return share;
    }
    
    /**
     * 
     * @param s Our session's secret that will be split into shares.
     * @param total The total number of shares to be generated
     * @param toCombine The minimum number of shares needed
     * @param prime The prime generated by our secret's bitLength and SecureRandom
     * @return 
     */
    public secrets[] getShares(BigInteger s, int total, int toCombine, BigInteger prime, BigInteger[] c) {
        setTotal(total);
        BigInteger share;
        secrets[] shares = new secrets[total];
        //BigInteger[] c = getCombineArray();
        for (int i = 1; i <= shares.length; i++) {
            share = s; //next s
            share = forEach(share,i,c,prime); //share += (coefficient #j i^j) % prime
            secrets sInit = new secrets(i,share);
            shares[i-1] = sInit;
        }
        return shares;
    }
    
    
    //earlier version of attempting to modInverse, then later realized that
    //BigInteger natively has a modInverse function
    // I kept it in so you could see my thought process in implementing :)
    // Would remove for a non-graded project
    /**
     * 
     * @param i Denominator: BigInteger.valueOf(start - next) -> d.multiply(dHelp).mod(prime);
     * @param prime The prime generated by our secret's bitLength and SecureRandom
     * @return Returns mod inverse of the int value of the BigIntegers back to BigInt (does not work)
     */
    public BigInteger helperFunction(BigInteger i, BigInteger prime) {
        int iInt = i.intValue();
        int primeInt = prime.intValue();
        
        for (int j = 1; j < primeInt; j++) {
            if ( ( (iInt%primeInt)*(j%primeInt)% primeInt ) == 1 ) {
                BigInteger jBI = BigInteger.valueOf(j);
                return jBI;
            }
        }
        return BigInteger.ONE;
    }
    
    /**
     * 
     * @param i Denominator: BigInteger.valueOf(start - next) -> d.multiply(dHelp).mod(prime);
     * @param prime The prime generated by our secret's bitLength and SecureRandom
     * @return Returns mod inverse using BigInteger's modInverse function.
     */
    public BigInteger helperFunctionn(BigInteger i, BigInteger helper, BigInteger prime) {
        //int iInt = i.intValue();
        //int primeInt = prime.intValue();
        BigInteger inverse = i.modInverse(prime);
        helper = helper.multiply(inverse);
        return helper;
    }
    
    /**
     * 
     * @param j index j
     * @param s secrets array
     * @param prime our prime
     * @return 
     */
    public BigInteger getNumerator(int j, secrets[] s, BigInteger prime) {
        int n = s[j].index;
        BigInteger nB = BigInteger.valueOf(n);
        nB = nB.negate().mod(prime);
        return nB;
    }
    
    /**
     * 
     * @param j index j
     * @param prime our prime
     * @param s secrets array
     * @param i index i
     * @return 
     */
    public BigInteger getDenominator(int j, BigInteger prime, secrets[] s, int i) {
        int n = s[j].index;
        int p = s[i].index;
        BigInteger dB = BigInteger.valueOf(p - n);
        return dB;
    }
    
    /**
     * 
     * @param n numerator
     * @param s secrets array
     * @param r output BigInteger (+= everything and mod by prime)
     * @param i index i
     * @param d denominator
     * @param prime our prime
     * @return 
     */
    public BigInteger combineNumDenom(BigInteger n, secrets[] s, BigInteger r, int i ,BigInteger d, BigInteger prime) {
            BigInteger out = s[i].secretShare;
            BigInteger helper = out.multiply(n);
            helper = helperFunctionn(d,helper,prime);
            r = prime.add(r).add(helper);
            r = r.mod(prime);
            return r;
    }
    
    
    
    /**
     * Uses the share combine formula with BigInteger's functionality (valueOf/negate/etc.)
     * Takes in the array of shares entered by the user and our session's prime.
     * Numerator = n * negate(s[j]).mod(prime)
     * Denominator = d * s[i] - s[j] .mod(prime)
     * Out += (s[i].share * n * modInverse(d,prime)).mod(prime)
     * until the end of the share array
     * @param s Shares entered by user
     * @param prime The session's prime generated by our secret's bitLength and SecureRandom.
     * @return return Out += (s[i].share * n * modInverse(d,prime)).mod(prime)
     */
    public BigInteger combineShares(secrets[] s, BigInteger prime) {
        int index = s.length;
        BigInteger r, n,d, nHelp, dHelp;
        r = BigInteger.valueOf(0);
        
        for(int i = 1; i < index; i++) {
            //reset numerator and denominator for the next s
            n = BigInteger.valueOf(1);
            d = BigInteger.valueOf(1);
            for (int j = 1; j < index; j++) {
                if (i != j) { //Skip when i == j or else nHelp and dHelp will mess up and zero
                n = getNumerator(j,s,prime);
                d = getDenominator(j,prime,s,i);
                }
            }
            r = combineNumDenom(n,s,r,i,d,prime);
        }
       // String bs = r.toString(16);
       // return bs;
        return r;
    }
    
  
    
    /**
     * 
     * @param fw PrintWriter to print to file
     * @param s Our session's secret
     * @param prime The session's prime generated by our secret's bitLength and SecureRandom.
     * @param toCombine The minimum number of shares needed
     * @param total The total number of keys to be generated
     * @return Returns the array of shares.
     */
    public secrets[] shareSplit(PrintWriter fw, BigInteger s, BigInteger prime, int toCombine, int total) {
        SecureRandom r = new SecureRandom();
    
        BigInteger[] c = getCoefficients(toCombine, r, s, prime);
        c[0] = s;
        secrets[] shares = getShares(s, total, toCombine, prime,c);
        
        for (secrets share : shares) {
            //String indx = Integer.toString(share.index);
            //byte[] b = share.secretShare.toByteArray();
            //String sha = b.toString();
            fw.println("Share " + share.index + ": " + share.secretShare);
        }
        return shares;
    }
    
    // This is another version of shareSplit that instead prints to console; otherwise identical
     public secrets[] shareSplit(BigInteger s, BigInteger prime, int toCombine, int total) {
        SecureRandom r = new SecureRandom();
    
        BigInteger[] c = getCoefficients(toCombine, r, s, prime);
        c[0] = s;
        secrets[] shares = getShares(s, total, toCombine, prime,c);
        
        for (secrets share : shares) {
            //String indx = Integer.toString(share.index);
            //byte[] b = share.secretShare.toByteArray();
            //String sha = b.toString();
            System.out.println("Share " + share.index + ": " + share.secretShare);
        }
        return shares;
    }
     
    
     /**
      * 
      * @param secret String share to make byte
      * @return Returns an array of BigInteger values based off the bytes of the string
      * @throws UnsupportedEncodingException 
      */
    public static BigInteger[] stringToByte(String secret) throws UnsupportedEncodingException {
        byte[] out = secret.getBytes("US-ASCII");
        int ind = out.length;
        BigInteger[] output = new BigInteger[ind];
        //System.out.println("ind: " + ind);
        for (int i = 0; i < ind; i++) {
            int helper = out[i];
            output[i] = BigInteger.valueOf(helper);
        }
        return output;
    }
    
    /**
     * This Part of the GUI allows the user to use the TEA algorithm to encrypt
     * or decrypt a file. The key can be created or revealed using the left panel
     * with Shamir's Secret Sharing
     * @param right JPanel to fill
     * @param layout GridLayout to utilize
     * @param tea2 Our instance of the tea algorithm
     * @param gbc GridLayout constraints
     * @return the filled out JPanel back out to main, where it is added.
     */
    public JPanel makeRight(JPanel right, GridBagLayout layout, Tea2 tea2, GridBagConstraints gbc) {
        right.setSize(300,500);
        right.setLayout(layout);

        JLabel inputPath = new JLabel("Encryption Path");
        JTextField filePath = new JTextField(20);
        JTextField secretKeyE = new JTextField(20);
        JButton inputButton = new JButton("Encrypt"); 
        JLabel success = new JLabel("");
        
        JLabel decryptPath = new JLabel("Decryption Path");
        JTextField decryptTextFPath = new JTextField(20);
        JTextField secretKeyD = new JTextField(20);
        JButton decryptButton = new JButton("Decrypt"); 
        JLabel dsuccess = new JLabel("");
        inputButton.addActionListener(
            new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    String path = filePath.getText();
                    String sec = secretKeyE.getText();
                    try {
                        encryptHex(sec,tea2,path);
                        success.setText("Succesfully encrypted to encrypted.txt");
                    } catch (IOException ex) {
                        Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }         
        );
        
        decryptButton.addActionListener(
            new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    String path = decryptTextFPath.getText();
                    String sec = secretKeyD.getText();
                    try {
                        String[] hex = hexToDecrypt(path);
                        String plainHex = decryptToPlainHex(hex, tea2, sec);
                        String plain = hexToPlain(plainHex);
                        outToFile(plain, "decrypted.txt");
                        dsuccess.setText("Succesfully decrypted to decrypted.txt");
                    } catch (IOException ex) {
                        Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            }         
        );
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridx = 0;
        gbc.gridy = 0;
        right.add(inputPath,gbc);
        gbc.gridx = 1;
        gbc.gridy = 0;
        right.add(filePath,gbc);
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(secretKeyE,gbc);
        gbc.gridx = 0;
        gbc.gridy = 2;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(inputButton,gbc);
        gbc.gridx = 0;
        gbc.gridy = 3;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(success,gbc);
        
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridx = 0;
        gbc.gridy = 4;
        right.add(decryptPath,gbc);
        gbc.gridx = 1;
        gbc.gridy = 4;
        right.add(decryptTextFPath,gbc);
        gbc.gridx = 0;
        gbc.gridy = 5;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(secretKeyD,gbc);
        gbc.gridx = 0;
        gbc.gridy = 6;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(decryptButton,gbc);
        gbc.gridx = 0;
        gbc.gridy = 7;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        right.add(dsuccess,gbc);
        
        
        return right;
    }
    
    /**
     * This side of the GUI allows the user to split their secret into shares
     * Then if they wish, combine the shares back out into their secret
     * It was created with a TEA key specifically in mind.
     * @param m Instance of main to use non-static variables
     * @param left JPanel left to fill
     * @param layout GridLayout
     * @param gbc GridLayout constraints
     * @return the filled JPanel left back out to main where it is then added.
     */
    public JPanel makeLeft(Main m, JPanel left, GridBagLayout layout, GridBagConstraints gbc) {
        left.setSize(500,700);
        left.setLayout(layout);
                
        JLabel labelSecret = new JLabel("Input secret message. (TEA Key)");
        JTextField inputSecret = new JTextField(20);
        JLabel tot = new JLabel("Total Shares:");
        JLabel need = new JLabel("Needed Shares:");
        JTextField inputTotal = new JTextField(5);
        JTextField inputToCombine = new JTextField(5);
        
        JLabel tooLarge = new JLabel("");
        JButton generateShares = new JButton("Generate Shares");
        JLabel outputSuccess = new JLabel("");
        generateShares.addActionListener(
            new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    String path = "shares.txt";
                    String sec = inputSecret.getText();
                    int t = Integer.parseInt(inputTotal.getText());
                    int c = Integer.parseInt(inputToCombine.getText());
                    if (c <= 5) {
                        tooLarge.setText("");
                        
                        //String secret = "a56babcdf000ffffffffffffabcdef01";
        //BigInteger[] keyIn = stringToByte(secret);
        BigInteger key = new BigInteger(sec,16); //initialize
        /*for (int index = 0; index < keyIn.length; index++) {
            key = key.add(keyIn[index]);
        }*/
        //System.out.println(key);
                        File file = new File(path);
                            try {
                                PrintWriter pw = new PrintWriter(file);
                                pw.write("");
                                pw.close();
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                            }
                            try {
                                PrintWriter fw = new PrintWriter(new FileWriter(file, true));
                                SecureRandom r = new SecureRandom();
                                BigInteger prime = new BigInteger(key.bitLength()+1, 256, r);
                                m.setPrime(prime);
                                PrintWriter prwP = new PrintWriter("prime.txt");
                                prwP.println(sessionPrime);
                                prwP.close();
                                PrintWriter prwC = new PrintWriter("combine.txt");
                                prwC.println(sessionCombine);
                                prwC.close();
                                fw.println("Prime: " + prime.toString() + "\n");
                                 //key, prime, shares to combine, total shares
                                sessionArr = m.shareSplit(fw, key, prime, c, t);
                                fw.close();
                                outputSuccess.setText("Shares generated to shares.txt");
                            } catch (FileNotFoundException ex) {
                                Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                            } catch (IOException ex) {
                                Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                            }
                         
                        
                    } else {
                        tooLarge.setText("Required shares too large (<5)");
                    }
                    
                }
            }         
        );
        
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridx = 0;
        gbc.gridy = 0;
        gbc.gridwidth = 2;
        left.add(labelSecret,gbc);
        gbc.gridx = 0;
        gbc.gridy = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(inputSecret,gbc);
        gbc.gridx = 0;
        gbc.gridy = 2;    
        gbc.fill = GridBagConstraints.HORIZONTAL;
        left.add(tot,gbc);
        gbc.gridx = 1;
        gbc.gridy = 2;    
        gbc.gridwidth = 1;
        left.add(inputTotal,gbc);
        gbc.gridx = 0;
        gbc.gridy = 3;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        left.add(need,gbc);
        gbc.gridx = 1;
        gbc.gridy = 3;      
        gbc.gridwidth = 1;
        left.add(inputToCombine,gbc);
        gbc.gridx = 0;
        gbc.gridy = 4;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(tooLarge,gbc);
        gbc.gridx = 0;
        gbc.gridy = 5;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(generateShares,gbc);
        gbc.gridx = 0;
        gbc.gridy = 6;      
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(outputSuccess,gbc);
        
        JLabel inputUsersShares = new JLabel("Input # of shares required by your instance.");
        JTextField share1 = new JTextField();
        JTextField share2 = new JTextField();
        JTextField share3 = new JTextField();
        JTextField share4 = new JTextField();
        JTextField share5 = new JTextField();
        JTextField primeT = new JTextField();
        JLabel share1L = new JLabel("1");
        JLabel share2L = new JLabel("2");
        JLabel share3L = new JLabel("3");
        JLabel share4L = new JLabel("4");
        JLabel share5L = new JLabel("5");
        JLabel primeL = new JLabel("Prime");
        //JLabel inputPrime = new JLabel("Input your instance's prime.");
        //JTextField textFPrime = new JTextField();
        JButton combineShares = new JButton("Combine");
        JLabel result = new JLabel("");
        combineShares.addActionListener(
            new ActionListener() {
                @Override
                public void actionPerformed(ActionEvent e) {
                    int index = 0;
                    if (!share1.getText().isBlank()) {
                        index++;
                    }
                    if (!share2.getText().isBlank()) {
                        index++;
                    }
                    if (!share3.getText().isBlank()) {
                        index++;
                    }
                    if (!share4.getText().isBlank()) {
                        index++;
                    }
                    if (!share5.getText().isBlank()) {
                        index++;
                    }
                    switch (index) {
                        case 1:
                            break;
                        case 2:
                        secrets[] session2 = new secrets[3];
                        session2[0] = new secrets(0,BigInteger.ONE);
                        BigInteger shareIn1 = new BigInteger(share1.getText());
                        //System.out.println(shareIn1);
                        secrets s0 = new secrets(1,shareIn1);
                        session2[1] = s0;
                        BigInteger shareIn2 = new BigInteger(share2.getText());
                        //System.out.println(shareIn2);
                        secrets s1 = new secrets(2,shareIn2);
                        session2[2] = s1;
                            //int check = 0;
                            
                    /*for (int i = 0; i < sessionArr.length;i++) {
                        for (int j = 0; j < session2.length; j++) {
                            if (session2[j].secretShare.compareTo(sessionArr[i].secretShare) == 0) {
                                check++;
                            }
                        }
                    }*/
                    //System.out.println(check);
                    //if (check == 2) {
                        BigInteger p = new BigInteger(primeT.getText());
                        BigInteger o = m.combineShares(session2, p);
                        result.setText("Secret output to out.txt");
                        try {
                            PrintWriter pw = new PrintWriter("out.txt");
                            pw.println("0x" + o.toString(16));
                            pw.close();
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    //}
                    break;
                    
                        case 3:
                            secrets[] session3 = new secrets[4];
                        session3[0] = new secrets(0,BigInteger.ONE);
                        shareIn1 = new BigInteger(share1.getText());
                        //System.out.println(shareIn1);
                        s0 = new secrets(1,shareIn1);
                        session3[1] = s0;
                        shareIn2 = new BigInteger(share2.getText());
                        //System.out.println(shareIn2);
                        s1 = new secrets(2,shareIn2);
                        session3[2] = s1;
                        BigInteger shareIn3 = new BigInteger(share3.getText());
                        //System.out.println(shareIn3);
                        secrets s2 = new secrets(3,shareIn3);
                        session3[3] = s2;
                        //check = 0;
                    /*for (int i = 0; i < sessionArr.length;i++) {
                        for (int j = 0; j < session3.length; j++) {
                            if (session3[j].secretShare.compareTo(sessionArr[i].secretShare) == 0) {
                                check++;
                            }
                        }
                    }*/
                    //System.out.println(check);
                    //if (check == 3) {
                        p = new BigInteger(primeT.getText());
                        o = m.combineShares(session3, p);
                        result.setText("Secret output to out.txt");
                        try {
                            PrintWriter pw = new PrintWriter("out.txt");
                            pw.println("0x" + o.toString(16));
                            pw.close();
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    //}
                    break;
                    
                        case 4:
                        secrets[] session4 = new secrets[5];
                        session4[0] = new secrets(0,BigInteger.ONE);
                        shareIn1 = new BigInteger(share1.getText());
                        //System.out.println(shareIn1);
                        s0 = new secrets(1,shareIn1);
                        session4[1] = s0;
                        shareIn2 = new BigInteger(share2.getText());
                        //System.out.println(shareIn2);
                        s1 = new secrets(2,shareIn2);
                        session4[2] = s1;
                        shareIn3 = new BigInteger(share3.getText());
                        //System.out.println(shareIn3);
                        s2 = new secrets(3,shareIn3);
                        session4[3] = s2;
                        BigInteger shareIn4 = new BigInteger(share4.getText());
                        //System.out.println(shareIn4);
                        secrets s3 = new secrets(4,shareIn4);
                        session4[4] = s3;
                        //check = 0;
                    /*for (int i = 0; i < sessionArr.length;i++) {
                        for (int j = 0; j < session4.length; j++) {
                            if (session4[j].secretShare.compareTo(sessionArr[i].secretShare) == 0) {
                                check++;
                            }
                        }
                    }*/
                    //System.out.println(check);
                    //if (check == 4) {
                        p = new BigInteger(primeT.getText());
                        o = m.combineShares(session4, p);
                        result.setText("Secret output to out.txt");
                        try {
                            PrintWriter pw = new PrintWriter("out.txt");
                            pw.println("0x" + o.toString(16));
                            pw.close();
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    //}
                    break;
                    
                        case 5:
                    
                    secrets[] session = new secrets[6];
                    session[0] = new secrets(0,BigInteger.ONE);
                    shareIn1 = new BigInteger(share1.getText());
                    //System.out.println(shareIn1);
                    s0 = new secrets(1,shareIn1);
                    session[1] = s0;
                    shareIn2 = new BigInteger(share2.getText());
                    //System.out.println(shareIn2);
                    s1 = new secrets(2,shareIn2);
                    session[2] = s1;
                     shareIn3 = new BigInteger(share3.getText());
                    //System.out.println(shareIn3);
                    s2 = new secrets(3,shareIn3);
                    session[3] = s2;
                    shareIn4 = new BigInteger(share4.getText());
                    //System.out.println(shareIn4);
                    s3 = new secrets(4,shareIn4);
                    session[4] = s3;
                    BigInteger shareIn5 = new BigInteger(share5.getText());
                    //System.out.println(shareIn5);
                    secrets s4 = new secrets(5,shareIn5);
                    session[5] = s4;
                    //check = 0;
                    /*for (int i = 0; i < sessionArr.length;i++) {
                        for (int j = 0; j < session.length; j++) {
                            if (session[j].secretShare.compareTo(sessionArr[i].secretShare) == 0) {
                                check++;
                            }
                        }
                    }*/
                    //System.out.println(check);
                    //if (check == 5) {
                        p = new BigInteger(primeT.getText());
                        o = m.combineShares(session, p);
                        result.setText("Secret output to out.txt");
                        try {
                            PrintWriter pw = new PrintWriter("out.txt");
                            pw.println("0x" + o.toString(16));
                            pw.close();
                        } catch (FileNotFoundException ex) {
                            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
                        }
                    //
                    
                }
                }
            }         
        );
        
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridx = 0;
        gbc.gridy = 7;
        gbc.gridwidth = 2;
        left.add(inputUsersShares,gbc);
        gbc.gridx = 0;
        gbc.gridy = 8;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(share1,gbc);
        left.add(share1L,gbc);
        gbc.gridx = 1;
        gbc.gridy = 8;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(share2,gbc);
        left.add(share2L,gbc);
        gbc.gridx = 0;
        gbc.gridy = 9;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(share3,gbc);
        left.add(share3L,gbc);
        gbc.gridx = 1;
        gbc.gridy = 9;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(share4,gbc);
        left.add(share4L,gbc);
        gbc.gridx = 0;
        gbc.gridy = 10;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(share5,gbc);
        left.add(share5L,gbc);
        gbc.gridx = 1;
        gbc.gridy = 10;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 1;
        left.add(combineShares,gbc);
        gbc.gridx =0;
        gbc.gridy = 11;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(primeT,gbc);
        left.add(primeL,gbc);
        gbc.gridx =0;
        gbc.gridy = 12;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.gridwidth = 2;
        left.add(result,gbc);
        
        
        return left;
    }
    
    
    public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException, FileNotFoundException, IOException {
        Main m = new Main();
        Tea2 tea2 = new Tea2();
        /*secrets[] s, v;
        String secret = "a56babcdf000ffffffffffffabcdef01";
        //BigInteger[] keyIn = stringToByte(secret);
        BigInteger key = new BigInteger(secret,16); //initialize
        /*for (int index = 0; index < keyIn.length; index++) {
            key = key.add(keyIn[index]);
        }
        System.out.println(key);
        
        SecureRandom r = new SecureRandom();
        BigInteger prime = new BigInteger(key.bitLength()+1, 256, r);
        System.out.println("Prime: " + prime.toString());
        //key, prime, shares to combine, total shares
        s = m.shareSplit(key, prime, 4, 7);
        
        //v = new secrets[4];
        m.combineShares(s, prime);*/
        

        
        JFrame f = new JFrame("Shamir's Secret Sharing");
        f.setLayout(new GridLayout(0,1));
        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        f.setSize(600,400);
        JPanel p = new JPanel();
        GridBagLayout layout = new GridBagLayout();
        GridBagConstraints gbc = new GridBagConstraints();
        
        p.setLayout(new FlowLayout());
        JPanel right = new JPanel();
        right = m.makeRight(right, layout, tea2,gbc);
        JPanel left = new JPanel();
        left = m.makeLeft(m,left,layout,gbc);
        
        p.add(left);
        p.add(right);
        f.add(p);
        f.setVisible(true);
        
        
        
        }
    }
    

